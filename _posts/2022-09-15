---
layout: post
title: Disposables and Dependency Injection
enable_mermaid: true
---

Chances that you've been using a dependency injection container in a C# application are extremely high. All DI containers I'm aware of provide the capability of a _child container_ or _scope_ as the Microsoft DI abstraction calls it. Scopes are providing a dedicated instance lifetime controlled by the user. Consider the following code:

```csharp
interface I1
{
}

interface I2 : I1
{
}

class Impl : I2, IDisposable
{
    public static int DisposeCounter { get; set; }

    public void Dispose()
    {
        DisposeCounter++;
    }
}
```

```csharp
serviceCollection.AddScoped<Impl>();

// build IServiceProvider

using (var scope = serviceProvider.CreateScope())
{
    var service = scope.ServiceProvider.GetService<Impl>();
}
```

Disposing the scope will also call dispose on our instance of `MyService` since it implements `IDisposable`. That's not too surprising, but let's look at some more complicated scenarios:

What will `DisposeCounter` be if the resolved type does not implement `IDisposable` (but the implementation does)?

```csharp
serviceCollection.AddScoped<I1>(_ => new Impl());

// build IServiceProvider

using (var scope = serviceProvider.CreateScope())
{
    var service = scope.ServiceProvider.GetService<I1>();
}
```

And does `DisposeCounter` change if we resolve the instance from the container too?

```csharp
serviceCollection.AddScoped<I1>(sp => sp.GetRequiredService<Impl>());
serviceCollection.AddScoped<Impl>();

// build IServiceProvider

using (var scope = serviceProvider.CreateScope())
{
    var service = scope.ServiceProvider.GetService<I1>();
}
```

And what happens if we resolve another interface which provides no compile-time information about the resolved implementation?

```csharp
serviceCollection.AddScoped<I1>(sp => sp.GetRequiredService<I2>());
serviceCollection.AddScoped<I2>(sp => sp.GetRequiredService<Impl>());
serviceCollection.AddScoped<Impl>();

// build IServiceProvider

using (var scope = serviceProvider.CreateScope())
{
    var service = scope.ServiceProvider.GetService<I1>();
}
```

As always, the answer is "it depends". In our case, it depends on the dependency injection container used.

## Microsoft ServiceProvider

Let's start with the Microsoft ServiceProvider. By now it's not just one of the most used DI containers but also pretty much acts as a reference implementation for many other DI containers.

If we build the `IServiceProvider` using `var serviceProvider = serviceCollection.BuildServiceProvider()` we get the following `DisposeCounter` values:

1. 1
1. 2
1. 3

From that we can conclude that the implementation [inspects the resolved instances at runtime](https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.DependencyInjection/src/ServiceLookup/ServiceProviderEngineScope.cs#L53) whether they implement `IDisposal` as the container registration can't determine the runtime type of the factory method (or at least not easily). However, The container doesn't deduplicate the disposable references to the same object instance (resolving the target service multiple times won't change the results).

## LightInject

Did you assume (or guess) the correct results for the ServiceProvider? If not, don't worry, there is still a chance a differt dependency injection container behaves the way you expected it to. Let's look at the results when we use LightInject by creating the `IServiceProvider` using `serviceCollection.CreateLightInjectServiceProvider()`:

1. 1
1. 1
1. 1

Similar to the Microsoft implementation, LightInject is also able to detect resolved instances implementing `IDisposable`. But LightInject avoids disposing the same instance multiple times.

We can confirm that (unsurprisingly) both containers follow the [dependency injection guidelines](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines) which states:

> The container is responsible for cleanup of types it creates, and calls Dispose on IDisposable instances. Services resolved from the container should never be disposed by the developer.

## A word of warning

When working with _scoped_ lifetime, we can rely on the DI container disposing the instances created. The previously mentioned guidelines also apply to services resolved in _transient_ scope though. When working with dispsosable services in _transient_ scope, carefully consult your DI containers documentation as the behavior there is much less consistent across containers, e.g. the [Ninject documentation](https://github.com/ninject/Ninject/wiki/Object-Scopes) states that transient services won't be disposed by the container. The Microsoft guidelines also explicitly recommend to not register `IDisposable` services in the transient lifetime:

> Don't register IDisposable instances with a transient lifetime. Use the factory pattern instead.

## Handling the ambuigity

Although we've seen that different containers might behave a bit different when disposing services, this should remain a fairly irrelevant detail in most cases. The Microsoft [guidelines on implementing `Dispose`](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose) states:

> To help ensure that resources are always cleaned up appropriately, a Dispose method should be idempotent, such that it is callable multiple times without throwing an exception. Furthermore, subsequent invocations of Dispose should do nothing.

As long as we stick to this guidline, the different implementations shouldn't affect the correctness of your system.


## Conclusion

Dependency injection containers do not only automatically dispose dependencies that directly implement `IDisposable` but will also take care of any disposable service implementation that is not visible to the consumer of the dependency. The exact behavior of the container in regards to disposing resolved instances can vary. For more complicated dependency chains, it can be tricky to predict the exact amount of times `Dispose` will be called on your class. However, this should ultimately belong in the "useless knowledge" category, because if you follow the general .NET coding guidelines, `Dispose` should be idempotent. That said, rest assured that there are plenty of implementations out there that might run into isuses in the shown examples (there is a reason this blog post exists ;)).