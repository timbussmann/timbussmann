---
layout: post
title: Manging repository standards using MSBuild and NuGet
---

At Particular Software, we do have quite a few repositories to maintain. At the time of writing this, there are about ~75 public repositories (that are not archived) in our organization. Using common repository settings and style checks helps to ensure that the the same coding guidelines and practices apply on every repository. But these standards also change, evolve or just need updates.

We have a [standards repository](https://github.com/Particular/RepoStandards) that acts as our baseline, basically like a repository template. The repository contains all the basic files that we want to share across all code repositores and changes to the standard settings are made here. It contains some pretty common files like:

* `.gitignore` and `.gitattributes`
* Standard license file
* `nuget.config`: We have [our own Nuget feed](https://www.myget.org/F/particular/api/v3/index.json) which we use to publish all sort of pre-release packages (and also the RTM packages before they are pushed to nuget). This file ensures that all our projects can direcly find and include packages that have been pushed to our own feed without the need to pollute the nuget.org feed. If you want to get RTM releases a few minutes earlier or want to work with our pre-release packages, you can also use our feed.
* virus-scan workflow: This is a [github action](https://github.com/features/actions) we use on all our repositories to automatically scan all releases built by this repository with a virus scanner.
* dependabot configuration: Dependabot is (after its acquisition) a feature of GitHub that helps us updating our (external and internal) dependencies across all repositries. With the amount of repositories we have, this saves a huge amount of effort by automating the majority of dependency updates.
* [Stale bot](https://github.com/apps/stale) configuration: This is a small GitHub app that can close abandonded PRs and issues. It's easy to forget some older PRs after some time with this many repositories. Stalebot pings authors of PRs after a while of no progress on a PR and ultimately closes the PR if the issue doesn't seem to be urgent enough.
* `.editorconfig`: We moved to [`.editorconfig`](https://docs.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options) to manage our code style settings. With this, all staff members have code style settings importet automatically and supported by major IDEs.
* [Strong-naming](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/strong-naming) certificates: The certificates are used to sign the assemblies that we publish as NuGet packages (the NuGet packages are signed with a separate certificate of course).
* `Directory.Build.props`: This is what we're going to have a closer look at in this post.

We use Azure Functions to sync these files on a schedule to every repostory that contains a `.reposync` file. That's already quite useful and makes managing shared standards a lot easier. The reposync file also allows to exclude certain files from syncing, in case a repository needs to override the defaults.

Let's look at the `Directory.Build.props` file, because this is where the magic for our C# projects (the majoritoy of our code base) comes from. `Directory.Build.props` is a [special file to customize the build process](https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build) in MSBuild. It will be automatically picked up if there is such a file anywhere inside your folder hierarchy based on the project file that is being built (there is also a targets file that behaves very similar), so we can just drop this file into our repository via the syncinc process. This allows to control the build behavior for every repository from a central file. Let's look at some interesting parts of that file (check out the [whole file](https://github.com/Particular/RepoStandards/blob/master/src/Directory.Build.props) if you're interested in every single detail):

```xml
<Import Project="Custom.Build.props" Condition="Exists('Custom.Build.props')" />
```

This import happens as the first thing to allow further customization or overrides in a specific repository. Instead of excluding the `Directory.Build.props` in the `.reposync` file and copying the file over manually, create a `Custom.Build.props` next to the `Directory.Build.props` and it will be run before the next parts in this post.

```xml
<ItemGroup>
    <PackageReference Include="Particular.Analyzers" Version="$(ParticularAnalyzersVersion)" PrivateAssets="All" />
</ItemGroup>
```

A neat feature is that it also allows us to define nuget package references that will automatically be included. As you can see, we have a package reference to a `Particular.Analyzers` package. The [Particular.Analyzers](https://github.com/Particular/Particular.Analyzers) package is a package that contains code analyzers that can detect certain code patterns. This allows us to enforce fairly sophisticated coding guidelines (e.g. handling cancellation tokens, tasks or dates) and even provide code fixes that are supported directly by the IDE.

![image showing a code analyzer warning](../assets/ps0022.png)

The image shows one of our custom analyzers complaining about implicitly casting a `DateTime` to a `DateTimeOffset` field.

Note: An important detail when using `Directory.Build.props` files is that the file detection stops at the first file found. Therefore, nested `Directory.Build.props` do not work out of the box but you can work around this by specifying `<Import Project="$([MSBuild]::GetPathOfFileAbove($(MSBuildThisFile), $(MSBuildThisFileDirectory)..))" Condition="Exists($([MSBuild]::GetPathOfFileAbove($(MSBuildThisFile), $(MSBuildThisFileDirectory)..)))" />` on the nested file. The analyzer repository makes use of this because it registers a [custom `Directory.Build.props` file](https://github.com/Particular/Particular.Analyzers/blob/master/src/Particular.Analyzers/Directory.Build.props) to **remove** the default dependency on the `Particular.Analyzers` package for itself.

There are also these settings we can briefly look into:

```xml
<PropertyGroup>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <EnableNETAnalyzers>true</EnableNETAnalyzers>
    <AnalysisLevel>5.0</AnalysisLevel>
    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
    <!-- To lock the version of Particular.Analyzers, for example, in a release branch, set this property in Custom.Build.props -->
    <ParticularAnalyzersVersion Condition="'$(ParticularAnalyzersVersion)' == ''">1.8.0</ParticularAnalyzersVersion>
    <NServiceBusKey>0024...3b92</NServiceBusKey>
    <NServiceBusTestsKey>0024...b1c5</NServiceBusTestsKey>
</PropertyGroup>
```

This is a bunch of code style related settings we can skim over quickly: `TreatWarningsAsErrors` forces the project build to fail rather than just showing warnings because nobody pays attentions to warnings till shit hits the fan (not just in software development unfortunately). `EnableNETAnalyzers` enables the [built-in Roslyn anlyzers](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview) and sets the version of the rules to a specific version using the `AnalysisLevel` property. Note that the Roslyn analyzers are enabled by default anyway, so this is a bit redundant but it's sometimes useful to be explicit. `EnforceCodeStyleInBuild` is another setting related to the Roslyn anlyzers that will allow the analyzers to fail the build (this setting is disabled by default). `ParticularAnalyzersVersion` is similar to `AnalysisLevel` and locks the importet analyzers package version (the version can be overriden by defining a custom version in a `Custom.Build.props` file). The `NServiceBusKey` and `NServiceBusTestsKey` contain the signature of the previously mentioned strong-naming certificates. With those available in being available in msbuild, [`InternalsVisibleTo`](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.internalsvisibletoattribute) can be used more comfortable directly in a `.csproj` file like this (since the assembly exposing internals is strong named, the assemblies allows to access internals must also be strong named):

```xml
<InternalsVisibleTo Include="NServiceBus.Core.Tests" Key="$(NServiceBusTestsKey)" />
```

This post gave a brief overview how we distribute and maintain repository standards and coding standards across many repositories with little effort and quite powerful capabilities like code analyzers. Thanks to a simple file-syncing mechanism and the `Directory.Build.props` file, we can basically control every aspect from developement to build time via a central repository.

![a diagram of showing how shared files are distributed across repositories](../assets/repo-standards.png)